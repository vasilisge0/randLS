
// Vectors used by Fgmres method.
template <ContextType device_type, typename value_type,
          typename value_type_internal_0, typename value_type_precond_0,
          typename index_type>
struct Workspace {
    std::shared_ptr<Context<device_type>> context_;
    // Scalars.
    index_type inc = 1;
    index_type max_iter_;
    // Vectors and matrices.
    value_type* u;
    value_type* v_basis;
    value_type* w;
    value_type* temp;
    value_type* residual;
    value_type_internal_0* w_in;
    value_type_internal_0* v_in;
    value_type_internal_0* z_in;
    value_type_internal_0* temp_in;
    value_type_internal_0* mtx_in;
    value_type* hessenberg_mtx;
    value_type* hessenberg_mtx_gpu;
    value_type* hessenberg_rhs_gpu;
    value_type* z_basis;
    value_type* hessenberg_rhs;
    value_type* sol0 = nullptr;
    std::shared_ptr<std::vector<std::pair<value_type, value_type>>>
        givens_cache;
    std::shared_ptr<matrix::Dense<CPU, value_type>> tmp_cpu;
    value_type alpha;
    value_type beta;
    value_type rho_bar;
    value_type phi_bar;
    value_type h;
    std::shared_ptr<matrix::Dense<device_type, value_type>> aug_sol;
    std::shared_ptr<matrix::Dense<device_type, value_type>> aug_residual;
    std::shared_ptr<matrix::Dense<device_type, value_type>> aug_rhs;
    static std::shared_ptr<
        Workspace<device_type, value_type, value_type_internal_0,
                  value_type_precond_0, index_type>>
    create(std::shared_ptr<Context<device_type>> context,
           std::shared_ptr<iterative::FgmresConfig<value_type, value_type_internal_0,
                                   value_type_precond_0, index_type>>
               config, dim2 size)
    {
        return std::shared_ptr<
            Workspace<device_type, value_type, value_type_internal_0,
                      value_type_precond_0, index_type>>(
            new Workspace<device_type, value_type, value_type_internal_0,
                          value_type_precond_0, index_type>(context, config,
                                                            size));
    }

    Workspace(std::shared_ptr<Context<device_type>> context,
              std::shared_ptr<iterative::FgmresConfig<value_type, value_type_internal_0,
                                      value_type_precond_0, index_type>>
                  config,
              dim2 size)
    {
        std::shared_ptr<Context<CPU>> context_cpu = Context<CPU>::create();
        context_ = context;
        max_iter_ = size[1];
        auto global_len = size[0] + size[1];
        memory::malloc<CUDA>(&u, global_len);
        memory::malloc<CUDA>(&v_basis, global_len * (max_iter_ + 1));
        memory::malloc<CUDA>(&z_basis, global_len * (max_iter_ + 1));
        memory::malloc<CUDA>(&w, global_len);
        memory::malloc<CUDA>(&temp, global_len);
        memory::malloc<CUDA>(&hessenberg_mtx_gpu, max_iter_ * (max_iter_ + 1));
        memory::malloc<CUDA>(&hessenberg_rhs_gpu, (max_iter_ + 1));
        memory::malloc<CPU>(&hessenberg_mtx, max_iter_ * (max_iter_ + 1));
        memory::malloc<CPU>(&hessenberg_rhs, max_iter_ + 1);
        memory::malloc<CUDA>(&residual, global_len);
        if (!std::is_same<value_type_internal_0, value_type>::value) {
            memory::malloc<CUDA>(&w_in, global_len);
            memory::malloc<CUDA>(&v_in, global_len);
            memory::malloc<CUDA>(&z_in, global_len);
            memory::malloc<CUDA>(&temp_in, global_len);
            memory::malloc<CUDA>(&mtx_in, global_len * size[1]);
        }
        memory::malloc<CUDA>(&sol0, size[0]);
        givens_cache =
            std::shared_ptr<std::vector<std::pair<value_type, value_type>>>(
                new std::vector<std::pair<value_type, value_type>>);
        givens_cache->resize(static_cast<size_t>(max_iter_ + 1));
        tmp_cpu = matrix::Dense<CPU, value_type>::create(context_cpu,
                                                         {max_iter_ + 1, 1});
        aug_sol = rls::share(matrix::Dense<CUDA, value_type>::create(context,
            {global_len, 1}));
        aug_residual = rls::share(matrix::Dense<CUDA, value_type>::create(context, {global_len, 1}));
        //aug_residual->zeros();
        aug_rhs = rls::share(matrix::Dense<CUDA, value_type>::create(context,
            {global_len, 1}));
    }

    ~Workspace()
    {
        memory::free<CUDA>(u);
        memory::free<CUDA>(v_basis);
        memory::free<CUDA>(z_basis);
        memory::free<CUDA>(w);
        memory::free<CUDA>(temp);
        memory::free<CUDA>(hessenberg_mtx_gpu);
        memory::free<CUDA>(hessenberg_rhs_gpu);
        memory::free<CPU>(hessenberg_mtx);
        memory::free<CPU>(hessenberg_rhs);
        memory::free<CUDA>(residual);
        //if (!std::is_same<value_type_in, value_type>::value) {
        //   memory::free(w_in);
        //   memory::free(v_in);
        //   memory::free(z_in);
        //   memory::free(mtx_in);
        //   memory::free(temp_in);
        //}
        memory::free<CUDA>(sol0);
    }
};
